import os
import re
from typing import List, Dict, Any, Optional
from tools.axiom.validators.base_validator import BaseValidator, Violation, ValidationResult

class LazyCodeValidator(BaseValidator):
    """
    Validator to detect 'lazy' code patterns often generated by AI agents.
    
    Checks for:
    - Empty method bodies or blocks containing only comments.
    - 'return null' or 'return Optional.empty()' in persistence layers.
    - 'TODO' comments in business-critical (domain) paths.
    """

    # Java method detection (simplified for pre-commit speed)
    # This regex looks for common method patterns followed by an empty or comment-only block
    EMPTY_METHOD_PATTERN = r"(?:public|private|protected|static|\s) +[\w<>\[\], ]+\s+\w+\s*\([^)]*\)\s*\{\s*(?://.*|/\*[\s\S]*?\*/|\s)*\}"
    
    # Persistence specific patterns
    LAZY_RETURN_PATTERNS = [
        (r"return\s+null\s*;", "CÓDIGO PEREZOSO: Retorno null en adaptador"),
        (r"return\s+Optional\.empty\s*\(\s*\)\s*;", "CÓDIGO PEREZOSO: Retorno empty en adaptador")
    ]
    
    # TODO patterns
    TODO_PATTERN = r"(?i)//\s*TODO|/\*\s*TODO"

    @property
    def name(self) -> str:
        return "lazy_code_validator"

    def validate(self, files: List[str]) -> ValidationResult:
        """Executes lazy code detection rules."""
        violations: List[Violation] = []
        
        for file_path in files:
            if not os.path.exists(file_path):
                continue
                
            # We only care about Java files for these specific rules
            if not file_path.endswith(".java"):
                continue
                
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    
                    # 1. Empty Method Detection (Global in Java files)
                    violations.extend(self._check_empty_methods(file_path, content))
                    
                    # 2. Persistence Layer Checks
                    if "/infrastructure/persistence/" in file_path:
                        violations.extend(self._check_persistence_lazy_patterns(file_path, content))
                        
                    # 3. Critical Path TODOs (Domain)
                    if "/domain/" in file_path:
                        violations.extend(self._check_critical_todos(file_path, content))
                        
            except Exception as e:
                # Log or handle read errors if necessary, though BaseValidator doesn't mandate it
                continue
                
        return ValidationResult(
            validator_name=self.name,
            violations=violations,
            success=len([v for v in violations if v.severity == "blocking"]) == 0
        )

    def _check_empty_methods(self, file_path: str, content: str) -> List[Violation]:
        violations = []
        # We use finditer to get line numbers if possible, or just search
        # NOTE: Regex for nested braces is notoriously hard. We'll stick to simple 
        # empty blocks `{ }` for the first version as specified.
        matches = re.finditer(self.EMPTY_METHOD_PATTERN, content)
        for match in matches:
            line_num = content.count('\n', 0, match.start()) + 1
            violations.append(Violation(
                file_path=file_path,
                message="CÓDIGO PEREZOSO: Método vacío detectado. Implementa la lógica o elimina el marcador.",
                severity="blocking",
                validator_name=self.name,
                line_number=line_num
            ))
        return violations

    def _check_persistence_lazy_patterns(self, file_path: str, content: str) -> List[Violation]:
        violations = []
        lines = content.splitlines()
        for i, line in enumerate(lines, 1):
            for pattern, msg in self.LAZY_RETURN_PATTERNS:
                if re.search(pattern, line):
                    violations.append(Violation(
                        file_path=file_path,
                        message=f"{msg}. Implementa la lógica real o lanza una excepción específica.",
                        severity="blocking",
                        validator_name=self.name,
                        line_number=i
                    ))
        return violations

    def _check_critical_todos(self, file_path: str, content: str) -> List[Violation]:
        violations = []
        lines = content.splitlines()
        for i, line in enumerate(lines, 1):
            if re.search(self.TODO_PATTERN, line):
                violations.append(Violation(
                    file_path=file_path,
                    message="TODO en módulo crítico detectado. Completa la implementación antes de commit.",
                    severity="blocking",
                    validator_name=self.name,
                    line_number=i
                ))
        return violations
