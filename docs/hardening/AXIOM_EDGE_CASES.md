# AXIOM Edge Cases

This document records specific edge cases and complex scenarios encountered during the AXIOM Domain Hardening process (Phase 1). These serve as reference for future maintenance and troubleshooting.

## 1. `Presupuesto` Integrity Hashes (Swiss-Grade Engineering)

**Scenario:**
The `Presupuesto` aggregate uses a dual-hash pattern (`integrityHashApproval`, `integrityHashExecution`) to ensure cryptographic integrity.

- `integrityHashApproval` is structurally immutable _logically_ (set once), but _technically_ mutable because it's null until the `approve()` method is called.
- `integrityHashExecution` updates dynamically with financial transactions.

**Handling:**
We suppressed `entity-final-fields` for these fields. This is an exception to the "Entity fields should be final" rule because the "Hard-Freeze" pattern enforces immutability at the application logic level (throwing exceptions if modified after sealing), rather than at the Java language level.

## 2. `ConfiguracionLaboralExtendida` Factors Map

**Scenario:**
This entity contains a `Map<TipoFactor, BigDecimal> factores`.
Semgrep flagged this as a mutable field. However, `ConfiguracionLaboral` represents a configuration that might evolve over time (though rarely).

**Handling:**
We suppressed the violation. The complexity here was correct suppression syntax. Semgrep's inline suppression must match the _exact_ rule ID generated by the context.

- **Fail:** `// nosemgrep: entity-final-fields`
- **Success:** `// nosemgrep: budgetpro.domain.immutability.entity-final-fields.rrhh`

**Lesson:** Always append the context suffix to rule IDs in suppressions.

## 3. `DetalleEstimacion` & `Estimacion` Calculation Chain

**Scenario:**
Fields like `montoBruto`, `importe`, `montoNetoPagar` are derived.
In a pure immutable model, these would be calculated on the fly:

```java
public BigDecimal getImporte() { return cantidad.multiply(precio); }
```

However, for reporting queries and performance, we persist these calculated values. This requires them to be fields, and thus mutable when their inputs change (e.g., updating `cantidad` updates `importe`).

**Handling:**
Accepted as "Calculated fields". The setter/update method is responsible for maintaining consistency (recalculating dependent fields immediately).

## 4. `Semgrep` Exclusion Pattern Behavior

**Scenario:**
We experienced duplicate violations when a file (e.g., `Presupuesto.java`) was scanned by both its specific context rule (`presupuesto`) and the catch-all rule (`finanzas_other`).
Attempts to exclude `presupuesto` from `finanzas_other` in `.domain-validator.yaml` initially failed.

**Root Cause:**

1. A typo in `generate_domain_rules.py` (`' exclusions'`) prevented exclusions from being used.
2. Confusion over relative paths vs. glob patterns (`**/`).

**Resolution:**
Fixed the python script and used simple relative paths in YAML. Validated that `finanzas_other` correctly ignores sub-context directories.

## 5. `ConfiguracionLaboralExtendida` fechaFin Nullability

**Scenario:**
`fechaFin` in `ConfiguracionLaboral` (and `AsignacionProyecto`) can be `null` to indicate "active/indefinite".
Standard immutable objects often prefer `Optional` or non-null fields over nulls.

**Handling:**
Allowed `null` for business semantic "Open-ended". This is not strictly a hardening issue but intersects with field definition. The field is mutable to allow "closing" the assignment later (setting the date).

---

**General Recommendation:**
When facing an edge case, prioritize **Architectural Integrity** (invariants, valid state) over strict **Language Immutability** (`final` keyword). If a field _must_ change to support the domain model's behavior, it is valid to be mutable, provided it is documented.
